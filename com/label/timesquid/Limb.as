package com.label.timesquid{	import net.eriksjodin.arduino.Arduino;	import net.eriksjodin.arduino.events.ArduinoEvent;	import net.eriksjodin.arduino.events.ArduinoSysExEvent;	import flash.utils.ByteArray;	import flash.events.Event;	import flash.events.EventDispatcher;	import com.label.timesquid.*;	public class Limb extends EventDispatcher {		// Constants:		// Public Properties:		// Private Properties:		var a:Arduino;		var numEvents:Number = 0;		var socket:String;		var port:int = 0;		var inputPort:int = 3;		var targetObj:ILimb;						// Initialization:		public function Limb(socket:String, port:int,targetObj:ILimb) {			this.socket = socket;			this.port = port;			//The target Movie Clip			this.targetObj = targetObj;						}		// Public Methods:		// Protected Methods:		public function connect() {			// connect to a serial proxy on port 5331			a = new Arduino(this.socket,this.port);			// listen for connection 			a.addEventListener(Event.CONNECT,onSocketConnect);			a.addEventListener(Event.CLOSE,onSocketClose);			// listen for firmware (sent on startup)			a.addEventListener(ArduinoEvent.FIRMWARE_VERSION, onReceiveFirmwareVersion);			// listen for data			a.addEventListener(ArduinoEvent.ANALOG_DATA, onReceiveAnalogData);			//a.addEventListener(ArduinoEvent.DIGITAL_DATA, onReceiveDigitalData);			//listen for sysex messages			a.addEventListener(ArduinoSysExEvent.SYSEX_MESSAGE, onReceiveSysExMessage);		}		// triggered when a serial socket connection has been established		public function onSocketConnect(e:Object):void {			trace("Socket connected!");			// request the firmware version			a.requestFirmwareVersion();		}		// triggered when a serial socket connection has been closed		public function onSocketClose(e:Object):void {			trace("Socket closed!");		}		// trace out data when it arrives...		public function onReceiveAnalogData(e:ArduinoEvent):void {			//trace((numEvents++) +" Analog pin " + e.pin + " on port: " + e.port +" = " + e.value);									//OK We have a value, what do we do to it now			if (e.pin==3)			{				targetObj.setValue(e.value);			}			//			testBlock.y = 200;		}		// trace out data when it arrives...		public function onReceiveDigitalData(e:ArduinoEvent):void {			trace((numEvents++) +" Digital pin " + e.pin + " on port: " + e.port +" = " + e.value);		}		// trace incoming sysex messages		public function onReceiveSysExMessage(e:ArduinoSysExEvent) {			trace((numEvents++) +"Received SysExMessage. Command:"+e.data[0]);		}		// the firmware version is requested when the Arduino class has made a socket connection.		// when we receive this event we know that the Arduino has been successfully connected.		public function onReceiveFirmwareVersion(e:ArduinoEvent):void {			trace("Firmware version: " + e.value);			if (int(e.value) != 2) {				trace("Unexpected Firmware version encountered! This Version of as3glue was written for Firmata2.");			}			// the port value of an event can be used to determine which board the event was dispatched from			// this is one way of dealing with multiple boards, another is to add different listener methods			trace("Port: " + e.port);			// do some stuff on the Arduino...			initArduino();		}		function initArduino():void {				trace("Initializing Arduino");							// enable reporting for an analog pin			a.setAnalogPinReporting(3, Arduino.ON);			//a.setAnalogPinReporting(4, Arduino.ON);			// disable reporting for an analog pin			//a.setAnalogPinReporting(3, Arduino.OFF);						// set a pin to PWM			//a.setPinMode(11, Arduino.PWM);						// write to PWM (0..255)			//a.writeAnalogPin(11, 255);						// trace out the most recently received data			//trace("Analog pin 3 is: " + a.getAnalogData(3));			//trace("Digital pin 4 is: " + a.getDigitalData(4));				// trace out the most recently received data			trace("Analog pin 3 is: " + a.getAnalogData(3));			trace("Hand (4) is: " + a.getAnalogData(4));								}	}}